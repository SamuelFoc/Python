# Performance Comparison: Synchronous, Threading, and AsyncIO

This repository contains a simple test script that compares the performance of different execution methods—Synchronous, Threading, and AsyncIO—when handling file operations. Specifically, the script measures the time taken to perform repeated file writes using different concurrency models.

## Overview

The test consists of the following steps:

1. **Workload Generation**: A small workload where a temporary file (`data-tmp.txt`) is written to 10 times in each iteration.
2. **Performance Measurement**: The execution times for each workload are measured using three different approaches:
   - Synchronous (blocking)
   - Threading (concurrent with threads)
   - AsyncIO (non-blocking asynchronous)
3. **Iterations**: The workload is tested with increasing numbers of iterations, ranging from 10 to 100,000 to simulate:
   - **Short, frequent writes** (10 iterations)
   - **Mid-size, mid-frequent writes** (100 to 10,000 iterations)
   - **Large, infrequent writes** (100,000 iterations)
4. **Data Visualization**: The results are plotted to show the performance differences across methods for various iteration counts.

## Prerequisites

This project requires Python 3.6+ and the following libraries:

- `matplotlib`: for plotting the performance data.
- `compare.utils`: a utility module to measure and compare performance (assumed to be part of this project or to be installed separately).

You can install the required dependencies via pip:

```bash
pip install matplotlib
```

Ensure the `compare.utils` module is available in your Python environment. It must define the following functions:

- `compare_performance(iteration_num, workload, callback, file_paths)`: Measures the time taken by synchronous, threading, and asyncio methods for the given workload and iteration count.
- `plot_data(data, iterations, methods)`: Plots the comparison of performance data for each method.

## Code Explanation

### Workload Function

The `workload()` function simulates a task by writing 10 lines to a file (`data-tmp.txt`). Each line consists of a dummy row:

```python
def workload():
    file_path = "data-tmp.txt"
    with open(file_path, "w") as file:
        for _ in range(10):
            file.write(f"{_} - This is a tmp data dummy row\n")
```

### Callback Function

The `callback()` function cleans up the temporary file generated by the workload:

```python
def callback(path):
    os.remove(path)
```

### Main Loop

The main loop iterates over a predefined set of iteration counts (`10, 100, 1000, 10000, 100000`). For each iteration count, it measures the performance of the workload using:

- Synchronous execution
- Threading
- AsyncIO

The results are appended to the `data` list:

```python
iterations = [10, 100, 1000, 10000, 100000]
data = []
for iteration_num in iterations:
    print(f"Iterations: {iteration_num}")
    synchronous_time, threading_time, asyncio_time = cmp.compare_performance(iteration_num, workload, callback, ["data-tmp.txt"])
    data.append([synchronous_time, threading_time, asyncio_time])
```

### Data Plotting

After collecting the performance data, the script uses `matplotlib` to visualize the results. The plot compares the time taken for each execution method across all iteration counts.

```python
methods = ['Synchronous', 'Threading', 'Asyncio']
cmp.plot_data(data, iterations, methods)
```

## Running the Test

To run the performance test, simply execute the script:

```bash
python performance_test.py
```

This will generate and display a performance comparison plot, showing the time taken for each method (Synchronous, Threading, AsyncIO) across various iteration counts.

## Output

The output will be a line graph where:

- The **x-axis** represents the number of iterations.
- The **y-axis** represents the time taken (in seconds).
- The three lines represent the performance of:
  - Synchronous execution
  - Threading execution
  - AsyncIO execution

## Conclusion

This test provides a comparative analysis of different concurrency approaches in Python for file I/O operations. It highlights how threading and asynchronous methods scale with increasing workloads, and how they compare to traditional synchronous execution.
